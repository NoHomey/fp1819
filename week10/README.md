# Week 10

## Частично прилагане на функции

Говорихме си, че всички функции в Haskell са всъщност curried функции на един аргумент.

Ако извикаме дадена функция с по-малко параметри, отколкото тя приема, получаваме частично приложена функция, която приема толкова аргумента, колкото остават.  

```haskell
-- sumThree :: (Int -> (Int -> (Int -> Int)))
sumThree :: Int -> Int -> Int -> Int
sumThree x y z = x + y + z  
```

Какво се случва когато извикаме следната функция?

```haskell
ghci> sumThree 1 2 3 -- или (((sumThree 1) 2) 3)
```

1. Първо прилагаме `sumThree` над `1`, което връща нова функция, която приема два параметъра и прибавя `1` към тях.
```haskell
sumTwoNumbersWithOne :: Int -> Int -> Int
sumTwoNumbersWithOne = sumThree 1
```

2. След това прилагаме `sumThree` над `2`, което връща нова функция, която приема един параметър и прибавя `3` към тях.
```haskell
sumTwoNumbersWithThree :: Int -> Int
sumTwoNumbersWithThree = sumThree 1 2
```

3. Накрая прилагаме `sumThree` над 3 и получаваме `6`.
```haskell
ghci> sumTwoNumbersWithThree 3 -- връща 6
```

Ето няколко (actually) смислени примера:

```haskell
-- функция, която приема число и го дели на 10
divideByTen :: Double -> Double  
divideByTen = (/10)

subtractTen :: Int -> Int
subtractTen = (subtract 10)  -- защото (- 10) има друго значение

-- функция, която примеа символ и проверява дали е главна буква
isUpperAlphanum :: Char -> Bool  
isUpperAlphanum = (`elem` ['A'..'Z'])  -- ще си говорим за този синтаксис по-долу
```

## lambda функции

lambda (анонимна) функция дефинираме по следния начин:

```haskell
(\аргумент1 aргумент2 .. aргументN -> тяло на функцията)
```

Пример:

```haskell
((\a b -> a + b) 1 2) -- връща 3
-- в scheme синтаксис: (lambda (a b) (+ a b))

((\a -> a + 3) 1)     -- връща 4
-- еквивалентно на (+ 3)
```

## Функции от по-висок ред

Също като в Scheme, функциите могат да приемат и връщат други функции.

```haskell
-- за дефинницията на типа на функцията използваме type променливи
-- четем - applyTwice приема:
-- 1. функция, която приема 1 аргумент от произволен тип a и връща резултат от същия тип a
-- 2. аргумент от същия този тип а
-- и връща резултат от същия този тип a
applyTwice :: (a -> a) -> a -> a  
applyTwice f x = f (f x)  
```

```haskell
ghci> applyTwice (+3) 10  -- връща 16
ghci> applyTwice (3:) [1] -- връща [3, 3, 1]
```

## Линейно обхождане на списъци

```haskell
sum' :: [Int] -> Int
sum' []     = 0
sum' (x:xs) = x + sum' xs
```

Нищо ново тук! Oтново имаме:
- дъно - празен ли е списъкът
- рекурсивно извикване с "опашката" на списъка (списъка без първия си елемент)

## Вградени функции за списъци

- `null` - проверява дали списъкът е празен

- `length`

- `head` (`car` в scheme), `tail` (`cdr` в scheme), `:` (`cons` в scheme)

  ```haskell
  1 : [2, 3]        -- връща списъка [1, 2, 3]
  1 : 2 : 3 : []    -- връща списъка [1, 2, 3]

  head [1, 2, 3]    -- връща 1
  tail [1, 2, 3]    -- връща [2, 3]
  ```

- `++` - конкатенира аргументите си в нов списък
  ```haskell
  [1, 2, 3] ++ [4] ++ [5, 6]  -- връща списъка [1, 2, 3, 4, 5, 6]
  ```

- `reverse`

- `elem`

  ```haskell
  elem 2 [1, 2, 3, 4]    -- връща True
  ```

- `!!` - достъпване на елемент по индекс

  ```haskell
  [1, 2, 3] !! 1   -- връща 2
  ```

- `take`

  ```haskell
  take 3 [1, 2, 3, 4, 5]    -- връща [1, 2, 3]
  ```

- `drop`

  ```haskell
  drop 3 [1, 2, 3, 4, 5]    -- връща [4, 5]
  ```

## Вградени функции от по-висок ред за списъци

- `map`

  ```haskell
  map (10 `div`) [1, 2, 5, 10] -- връща [10, 5, 2, 1]
  ```

- `filter`

  ```haskell
  filter (< 5) [1, 2, 7, 3, 4, 5, 6, 8, 9, 10] -- връща [1, 2, 3, 4]
  ```

- `foldl`

  ```haskell
  sum' :: [Int] -> Int  
  sum' xs = foldl (\acc x -> acc + x) 0 xs  -- или foldl + 0 xs
  ```

- `foldr`

  ```haskell
  map' :: (a -> b) -> [a] -> [b]  
  map' f xs = foldr (\x acc -> f x : acc) [] xs  
  ```

- `takeWhile`

  ```haskell
  takeWhile (< 5) [1, 2, 7, 3, 4, 5, 6, 8, 9, 10] -- връща [1, 2]
  ```

## Ranges

Чрез range създаваме списък от изброими елементи (такива, при които има ред - знаем какво следва след всеки елемент - примерно, числа и символи).

```haskell
ghci> [1..10]  
-- връща [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

ghci> ['a'..'z']  
-- връща "abcdefghijklmnopqrstuvwxyz"

ghci> [1, 3..10]   -- можем да зададем и стъпка
-- връща [1, 3, 5, 7, 9]

ghci> [1, -1..(-10)] -- връща [1, -1, -3, -5, -7, -9]
```

## List comprehensions

```haskell
ghci> [x * 2 | x <- [1..5]]                   -- връща [2, 4, 6, 8, 10]  
ghci> [x * 2 | x <- [1..10], x * 2 < 5]       -- връща [2, 4]
ghci> [(x, y)| x <- [1, 2, 3], y <- [4, 5]]   -- връща [(1, 4), (1, 5), (2, 4), (2, 5), (3, 4), (3, 5)]
```

## Задачи

1. Дефинирайте функция `flip function`

2. Дефинирайте функция `applyMultiple number f arg`, която прилага функцията f n пъти пример:

  ```haskell
  applyMultiple 3 sqrt 256    -- връща 2
  ```

3. Дефинирайте `replicate' n element`, която конструира списък от `n` повторения на даден обект `element`

  ```haskell
  replicate' 5 10   -- връща [10,10,10,10,10]
  ```

4. (Анди) Дефинирайте функция `count pred a b`, която проверява за колко измежду числата в целочисления интервал `[a, b]` е верен предикатът `pred`

5. Дефинирайте функция `zipWith xs1 xs2 function`

6. (Анди) Дефинирайте функция `count xs`, която брои срещанията на всеки елемент в списъка `xs`

  ```haskell
  count [1, 1, 2, 3, 3, 3, 4, 2, 2, 2, 2, 1] -- връща [(1, 3), (2, 5), (3, 3), (4,1)]
  ```

7. (Анди) Дефинирайте функция `compress xs`, която брои последователните срещанията на всеки елемент в списъка `xs`

  ```haskell
  compress [1, 1, 2, 3, 3, 3, 4, 2, 2, 2, 2, 1] -- връща [(1, 2), (2, 1), (3, 3), (4, 1), (2, 4), (1, 1)]
  ```

8. (Анди) Дефинирайте функция `maxDistance xs`, която приема списък от точки (наредени двойки (Double, Double)) и връща дължината на най-дългата отсечка между *някои две* от тях

  ```haskell
  maxDistance [(-1.1, 1), (1.8, 2), (3, 1), (-1, -2)]     -- връща 5.0
  ```

9. Да се дефинира функция `permutable start end f g`, която по дадени две естествени числа `start` и `end` и две едноместни числови функции `f` и `g` проверява дали за всички четни числа `x` в интервала `[start, end]` е изпълнено, че `f(g(...f(g(x))...)) = g(f(...g(f(x))...))`, където общият брой прилагания на функции от всяка страна наравенството е `x`.

  ```haskell
  double x = x * x
  triple x = x * x * x

  permutable 1 9 double triple   -- връща True
  ```

10. Да се дефинира функция `findMax f start end`, която по дадена двуместна числова функция `f` и цели числа `start` и `намира` най-голямата стойност от вида `f(i, f(i+1, … f(j-1, j))` за `start ≤ i < j ≤ end`.

  ```haskell
  findMax (-) 1 5  -- връща 4
  ```
