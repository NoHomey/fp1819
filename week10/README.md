# Week 10

## Частично прилагане на функции

Говорихме си, че всички функции в Haskell са всъщност curried функции на един аргумент.

Ако извикаме дадена функция с по-малко параметри, отколкото тя приема, получаваме частично приложена функция, която приема толкова аргумента, колкото остават.  

```haskell
-- sumThree :: (Int -> (Int -> (Int -> Int)))
sumThree :: Int -> Int -> Int -> Int
sumThree x y z = x + y + z  
```

Какво се случва когато извикаме следната функция?

```haskell
ghci> sumThree 1 2 3 -- или (((sumThree 1) 2) 3)
```

1. Първо прилагаме `sumThree` над `1`, което връща нова функция, която приема два параметъра и прибавя `1` към тях.
  ```haskell
  sumTwoNumbersWithOne :: Int -> Int -> Int
  sumTwoNumbersWithOne = sumThree 1
  ```

2. След това прилагаме `sumThree` над `2`, което връща нова функция, която приема един параметър и прибавя `3` към тях.
  ```haskell
  sumTwoNumbersWithThree :: Int -> Int
  sumTwoNumbersWithThree = sumThree 1 2
  ```

3. Накрая прилагаме `sumThree` над 3 и получаваме `6`.
  ```haskell
  ghci> sumTwoNumbersWithThree 3 -- връща 6
  ```

Ето няколко (actually) смислени примера:

```haskell
-- функция, която приема число и го дели на 10
divideByTen :: Double -> Double  
divideByTen = (/10)

subtractTen :: Int -> Int
subtractTen = (subtract 10)  -- защото (- 10) има друго значение

-- функция, която примеа символ и проверява дали е главна буква
isUpperAlphanum :: Char -> Bool  
isUpperAlphanum = (`elem` ['A'..'Z'])  -- ще си говорим за този синтаксис по-долу
```

## lambda функции

lambda (анонимна) функция дефинираме по следния начин:

```haskell
(\аргумент1 aргумент2 .. aргументN -> тяло на функцията)
```

Пример:

```haskell
((\a b -> a + b) 1 2) -- връща 3
-- в scheme синтаксис: (lambda (a b) (+ a b))

((\a -> a + 3) 1)     -- връща 4
-- еквивалентно на (+ 3)
```

## Функции от по-висок ред

Също като в Scheme, функциите могат да приемат и връщат други функции.

```haskell
-- за дефинницията на типа на функцията използваме type променливи
-- четем - applyTwice приема:
-- 1. функция, която приема 1 аргумент от произволен тип a и връща резултат от същия тип a
-- 2. аргумент от същия този тип а
-- и връща резултат от същия този тип a
applyTwice :: (a -> a) -> a -> a  
applyTwice f x = f (f x)  
```

```haskell
ghci> applyTwice (+3) 10  -- връща 16
ghci> applyTwice (3:) [1] -- връща [3, 3, 1]
```

## Линейно обхождане на списъци

```haskell
sum' :: [Int] -> Int
sum' []     = 0
sum' (x:xs) = x + sum' xs
```

Нищо ново тук! Oтново имаме:
- дъно - празен ли е списъкът
- рекурсивно извикване с "опашката" на списъка (списъка без първия си елемент)

## Вградени функции за списъци

- `null` - проверява дали списъкът е празен

- `length`

- `head` (`car` в scheme), `tail` (`cdr` в scheme), `:` (`cons` в scheme)

  ```haskell
  1 : [2, 3]        -- връща списъка [1, 2, 3]
  1 : 2 : 3 : []    -- връща списъка [1, 2, 3]

  head [1, 2, 3]    -- връща 1
  tail [1, 2, 3]    -- връща [2, 3]
  ```

- `++` - конкатенира аргументите си в нов списък
  ```haskell
  [1, 2, 3] ++ [4] ++ [5, 6]  -- връща списъка [1, 2, 3, 4, 5, 6]
  ```

- `reverse`

- `elem`

  ```haskell
  elem 2 [1, 2, 3, 4]    -- връща True
  ```

- `!!` - достъпване на елемент по индекс

  ```haskell
  [1, 2, 3] !! 1   -- връща 2
  ```

- `take`

  ```haskell
  take 3 [1, 2, 3, 4, 5]    -- връща [1, 2, 3]
  ```

- `drop`

  ```haskell
  drop 3 [1, 2, 3, 4, 5]    -- връща [4, 5]
  ```

## Вградени функции от по-висок ред за списъци

- `map`

  ```haskell
  map (10 `div`) [1, 2, 5, 10] -- връща [10, 5, 2, 1]
  ```

- `filter`

  ```haskell
  filter (< 5) [1, 2, 7, 3, 4, 5, 6, 8, 9, 10] -- връща [1, 2, 3, 4]
  ```

- `foldl`

  ```haskell
  sum' :: [Int] -> Int  
  sum' xs = foldl (\acc x -> acc + x) 0 xs  -- или foldl + 0 xs
  ```

- `foldr`

  ```haskell
  map' :: (a -> b) -> [a] -> [b]  
  map' f xs = foldr (\x acc -> f x : acc) [] xs  
  ```

- `takeWhile`

  ```haskell
  takeWhile (< 5) [1, 2, 7, 3, 4, 5, 6, 8, 9, 10] -- връща [1, 2]
  ```

## Ranges

Чрез range създаваме списък от изброими елементи (такива, при които има ред - знаем какво следва след всеки елемент - примерно, числа и символи).

```haskell
ghci> [1..10]  
-- връща [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

ghci> ['a'..'z']  
-- връща "abcdefghijklmnopqrstuvwxyz"

ghci> [1, 3..10]   -- можем да зададем и стъпка
-- връща [1, 3, 5, 7, 9]

ghci> [1, -1..(-10)] -- връща [1, -1, -3, -5, -7, -9]
```

## List comprehensions

```haskell
ghci> [x * 2 | x <- [1..5]]                   -- връща [2, 4, 6, 8, 10]  
ghci> [x * 2 | x <- [1..10], x * 2 < 5]       -- връща [2, 4]
ghci> [(x, y)| x <- [1, 2, 3], y <- [4, 5]]   -- връща [(1, 4), (1, 5), (2, 4), (2, 5), (3, 4), (3, 5)]
```

## Задачи

1. Дефинирайте функция `flip' function`

  ```haskell
  ghci> mod 5 3          -- връща 2 (5 `mod` 3 = 2)
  ghci> flip' mod 5 3    -- връща 3 (3 `mod` 5 = 3)
  ```

2. Дефинирайте функция `applyMultiple times f arg`, която прилага функцията f n пъти пример:

  ```haskell
  ghci> applyMultiple 3 sqrt 256    -- връща 2.0
  ```

3. Дефинирайте `replicate' n element`, която конструира списък от `n` повторения на даден обект `element`

  ```haskell
  ghci> replicate' 5 10   -- връща [10,10,10,10,10]
  ```

4. (Анди) Дефинирайте функция `filterCount pred a b`, която проверява за колко измежду числата в целочисления интервал `[a, b]` е верен предикатът `pred`

  ```haskell
  ghci> filterCount even 1 10   -- връща 5
  ```

5. Дефинирайте функция `zip' xs1 xs2`, която връща списък от наредени двойки

  ```haskell
  ghci> zip' [1,2,3] "abcd"   -- връща [(1, 'a'), (2, 'b'), (3, 'c')]
  ```

6. (Анди) Дефинирайте функция `histogram xs`, която брои срещанията на всеки елемент в списъка `xs`

  ```haskell
  ghci> histogram [1, 1, 2, 3, 3, 3, 4, 2, 2, 2, 2, 1] -- връща [(1, 3), (2, 5), (3, 3), (4,1)]
  ```

7. (Анди) Дефинирайте функция `compress xs`, която брои последователните срещанията на всеки елемент в списъка `xs`

  ```haskell
  ghci> compress [1, 1, 2, 3, 3, 3, 4, 2, 2, 2, 2, 1] -- връща [(1, 2), (2, 1), (3, 3), (4, 1), (2, 4), (1, 1)]
  ```

8. (Анди) Дефинирайте функция `maxDistance xs`, която приема списък от точки (наредени двойки (Double, Double)) и връща дължината на най-дългата отсечка между *някои две* от тях

  ```haskell
  ghci> maxDistance [(-1.1, 1), (1.8, 2), (3, 1), (-1, -2)]     -- връща 5.0
  ```

9. Дефинирайте функция `shift lst`, която залепя първия елемент да списъка в края му
  ```haskell
  ghci> shift [1, 2, 3]    -- връща [2, 3, 1]
  ghci> shift "eat"        -- връща "ate"
  ```

10. Дефинирайте функция `rotate xs i`, която премества всеки елемент от списъка `xs` с `i` позиции наляво
  ```haskell
  ghci> rotate "abcdefgh" 3         -- връща "defghabc"
  ghci> rotate "abcdefgh" (-2)      -- връща "ghabcdef"
  ```

10. Използвайки някой `fold` дефинирайте (http://www.cantab.net/users/antoni.diller/haskell/questions/quest06.pdf):
  - `minimum' xs` - намира най-малкият елемент в списък
  - `remdups  xs` - премахва последователните повторения да даден елемент в списък
    ```haskell
    ghci> remdups [1, 2, 2, 3, 3, 3, 1, 1]    -- връща [1, 2, 3, 1]
    ```
  - `inits xs` - връща всички представи на списъка `xs`
    ```haskell
    ghci> intis "ate" = [[], "a", "at", "ate"]
    ```
  - `rotations xs` - генерира всички ротации на списъка `xs`
    ```haskell
    ghci> rotations [1, 2, 3]       -- връща [[1, 2, 3], [2, 3, 1], [3, 1, 2]]
    ```

11. Дефинирайте функция `pairs n`, която връща всички наредени двойки от типа `(x, y)`, `1 ≤ x, y ≤ n`

  ```haskell
  pairs 3 -- връща [(1, 2),(1, 3),(2, 1),(2, 3),(3, 1),(3, 2)].
  ```

12. Дефинирайте функция `compose xs` със следната типова дефиниция:
  ```haskell
  compose :: [(a, b)] -> [(b, c)] -> [(a, c)]
  ```

  `compose` приема 2 списъкa от наредени двойки и връща нов списък от наредени двойки, конструиран по следния начин:
  ако в първия списък има наредена двойка `(x, y)`, a във втория - `(y, z)`, резултатът ще съдържа наредената двойка `(x, z)`

  ```haskell
  compose [(1, 2), (7, 11), (8, 10)] [(2, 3), (11, 14)]  -- връща [(1, 3), (7, 14)]
  ```

13. Да се дефинира функция `permutable start end f g`, която по дадени две естествени числа `start` и `end` и две едноместни числови функции `f` и `g` проверява дали за всички четни числа `x` в интервала `[start, end]` е изпълнено, че `f(g(...f(g(x))...)) = g(f(...g(f(x))...))`, където общият брой прилагания на функции от всяка страна наравенството е `x`.

  ```haskell
  double x = x * x
  triple x = x * x * x

  permutable 1 9 double triple   -- връща True
  ```

14. Да се дефинира функция `findMax f start end`, която по дадена двуместна числова функция `f` и цели числа `start` и `end` намира най-голямата стойност от вида `f(i, f(i+1, … f(j-1, j))` за `start ≤ i < j ≤ end`.

  ```haskell
  findMax (-) 1 5  -- връща 4
  ```
