# Подготовка за Контролно 2

## Уточнение
  Материалът за второто контролно е до списъци в Haskell, включително функции от по-висок ред над тях.

## Контролно по ФП, 2017/2018

**Задача 1**  

Да се напише функция `mostFrequent`, която по даден списък от списъци от числа връща числото, което е сред най-често срещаните числа във всички списъци, ако такова има, или 0 иначе.

```haskell
ghci> mostFrequent [[1,1,3,2],[1,1,5],[1,5],[1,1,1,3]]      -- връща 1
ghci> mostFrequent [[1,1,3,2],[1,5,5],[1,5],[1,1,1,3]]      -- връща 0
```

**Задача 2** (scheme)  

a. Да се напише функция `grow t x`, която по дадено двоично дърво от числа t конструира ново, в което към всяко листо на t добавя по две нови листа със зададена стойност x.  

b. Двоично дърво наричаме “пълно”, ако има 2^n елемента на ниво n. Да се напише функция `growingTrees`, която генерира безкраен поток от пълни дървета с височини съответно 1, 2, 3,..., като всички елементи на ниво n са със стойност n.  

**Задача 3**  

Телевизионно предаване се представя с наредена тройка от име (низ), начален час (наредена двойка от час и минути) и продължителност (брой минути). Телевизионна програма наричаме последователност от предавания, чиито интервали на излъчвания са подредени в нарастващ ред и не се пресичат.  

a. Да се напише функция `lastShow`, което по списък от предавания връща името на това, което завършва най-късно.  

b. Да се напише функция `longestProgram`, която по даден списък от предавания генерира възможно най-дълга телевизионна програма, т.е. сумата от продължителностите на предаванията в нея е максимална.

```haskell
ghci> let tvShows = [("A",(11,0),120),("B",(12,0),15),("C",(10,30),90)]

ghci> lastShow tvShows            -- връща "A", защото предаването "A" свърщва в 13 часа
ghci> longestProgram tvShows      -- връща [("A",(11,0),120)]
```

## Контролно по ФП, 2016/2017

**Задача 1**  

Нека е даден списък от наредени двойки от числа, представляващи точки в равнината. Да се напише функция `findMedoid`, която намира такава точка от списъка, за която сумата от квадратите на разстоянията до всички останали точки в списъка е минимална.

```haskell
findMedoid [(2,8),(-2,4),(1,2),(-4,-1),(5,0)]   -- връща (1,2)
```

**Задача 2**  

Да се напише функция `sumLast`, която приема две положителни естествени числа k и n и генерира безкрайния поток, в който първото число е k, а всяко следващо число е равно на сумата от предходните n числа в потока.

```scheme
(sumLast 3 5)     ;; (3 3 6 12 24 48 93 183 … )
```
```haskell
sumLast 3 5       -- [3, 3, 6, 12, 24, 48, 93, 183, … ]
```

**Задача 3**

Нека е даден ориентиран граф със символи по върховете и целочислени тегла по върховете, който е представен чрез списъци от наследници по следния начин:

scheme
```scheme
(define G ‘((a 2 b c)
            (b 4 a c)
            (c 1 a b)))
```

haskell
```haskell
g :: [(Char,Int,[Char])]
g =  [('a', 2, "bc"),
      ('b', 4, "ac"),
      ('c', 1, "ab")]
```
Да се напише функция `eulerCycleCost`, която проверява дали графът съдържа Ойлеров цикъл и ако да, връща цената му (сборът от теглата на върховете, през които минава). Ако Ойлеров цикъл няма, да се върне 0.

**Задача 4** (scheme)

Да се напише функция `transformSum`, която преобразува дърво с елементи цели числа в ново дърво със същата структура, в което всеки елемент е заменен със сумата на елементите в поддървото с този корен в началното дърво.

## Контролно по ФП, 2015/2016

**Задача 1**  

За тази задача ще представяме множествата като списъци от елементи, които могат да бъдат сравнявани с предикати за равенство и за наредба (т.е. == и < в Haskell, equal? и < в Scheme). Елементите в тези списъци не могат да се повтарят и трябва да са в строго нарастващ ред. Да се реализират основните операции над множества: `setUnion` (обединение), `setIntersect` (сечение), `setDiff` (разлика) и `setSymDiff` (симетрична разлика) така, че резултатът на операциите отново да са множества, представени като сортирани в нарастващ ред списъци:

```haskell
setUnion [1,2,3,4,5] [2,3,5,6]
-- връща [1,2,3,4,5,6]
-- а не [1,2,3,3,4,5,5,6]
-- нито [1,2,3,4,5,2,3,5,6]

setIntersect [1,2,3,4,5] [2,3,5,6] -- връща [2,3,5]
setDiff [1,2,3,4,5] [2,3,5,6] -- връща [1,4]
setDiff [2,3,5,6] [1,2,3,4,5] -- връща [6]
setSymDiff [1,2,3,4,5] [2,3,5,6] -- връща [1,4,6]
```

Забранена е употребата на вградени функции, които извършват същите операции!

**Задача 2**  

Да се напише функция `lfsort`, която приема като параметър списък от списъци и го сортира по честотата, с която се срещат дължините на вътрешните списъци:

```haskell
lfsort ["abc", "de", "fgh", "fp", "ijkl", "mn", "o"]
-- връща ["ijkl", "o", "abc", "fgh", "fp", "de", "mn"]
```

Наредбата между вътрешните списъци, които са “еквивалентни” в този смисъл – т.е. техните дължини се срещат еднакъв брой пъти – няма значение.

Упътване: можете да напишете и използвате помощна функция histogram, която приема един списък с произволни елементи и изгражда списък от наредени двойки с всеки негов елемент и броя срещания в списъка:

```haskell
histogram [1,2,2,3,4,2,1,2]   -- връща [(1,2), (2,4), (3,1), (4,1)]
```

**Задача 3** (scheme)  

Да се напише функция `prune`, която по дадено двоично дърво t връща ново дърво t', което представлява t, в което всички листа са премахнати.
