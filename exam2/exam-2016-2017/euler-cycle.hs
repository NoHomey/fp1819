-- Нека е даден ориентиран граф със символи по върховете и целочислени тегла по върховете,
-- който е представен чрез списъци от наследници по следния начин:

g :: [(Char,Int,[Char])]
g =  [('a', 2, "bc"),
      ('b', 4, "ac"),
      ('c', 1, "ab")]

-- Да се напише функция eulerCycleCost,
-- която проверява дали графът съдържа Ойлеров цикъл и ако да,
-- връща цената му (сборът от теглата на върховете, през които минава).
-- Ако Ойлеров цикъл няма, да се върне 0.

-- Ойлеров цикъл – преминава през всяко ребро еднократно (през възлите може да се минава многократно)
-- необходимо и достатъчно условие да има Ойлеров цикъл във свързан граф е за всеки връх броят на входините и изходните ребра е равен


-- parents :: Char -> [(Char, Int, [Char])] -> [Char]
-- TODO: функция, която приема връх и граф, и връща родителите на този връх в графа

-- children :: Char -> [(Char, Int, [Char])] -> [Char]
-- TODO: функция, която приема връх и граф, и връща децата на този връх в графа

-- eulerCycleCost :: [(Char, Int, [Char])] -> Int
-- TODO:
-- провери дали графът е свързан
-- провери дали броят на входните ребра е равен на броя на изходните ребра за всеки връх
-- ако горните две условия са истина, в графа съществува Ойлеров цикъл
-- през всеки връх минаваме толкова пъти, колкото е степента на вход (= степента на изход) пъти
-- т.е. ако един връх има 3 деца, през него минаваме 3 пъти и теглото му влиза 3 пъти в общата сума
-- основна логика: sum (map (\(_, weight, children) -> weight * (length children)) graph)
