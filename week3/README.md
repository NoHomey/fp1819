# Week 3

- let и let*
- функции от по-висок ред
- sum, product, accum
- lambda функции

## let и let*

```scheme
(define (lo6o a b)
    (+ 
        (- (* 3 a) b)
        (+ (* 3 a) b)))
```
Какъв и е проблемът на тази функция?  
Разни неща се повртарят - бихме искали да ги изнесем в (локални) променливи и изчислим само по веднъж.

```scheme
(define (less-lo6o a b)
    (let 
        ((triple-a (* 3 a)))
    (+
        (- triple-a b)
        (+ triple-a b))))
```

### let  
-  използва се често за опростяване на израз, който съдържа 2 (или повече) еднакви подизраза
- синтаксис  
    
    ```scheme
    (let 
        ((variable1 value1)
         (variable2 value2)
         ;; ...
         (variablen valuen))
    body)
    ```

- първо се изчисляват всички value изрази и след това се свързват с променливите си variable
    
    ```scheme
    ;; връща 3
    (let
        ((a 2)
         (b 1))
    (+ a b))

    ;; грешка - cannot reference an identifier before  
    ;; its definition - променливата а все още не е  
    ;; свързана със стойността
    (let
        ((a      2)
         (b (+ a 1)))
    (+ a b))
    ```

- променливите, свързани със стойността си в let-израз, са видими само в тялото на let-израза

    ```scheme
    ;; понеже изразите на първо място в скобите при прилагане на функции  
    ;; (примерно плюсът в (+ 2 3)) се оценяват по същия начин като всички  
    ;; останали изрази, можем и тях да свързваме с променлива в let израз
    (let 
        ((+ *))
    (+ 2 3))        ;; в тялото на let - връща 6
    
    (+ 2 3)         ;; връща 5
    ```
- възможно е да имаме вложени let-изрази
    
    ```scheme
    ;; връща 35
    ;; стойността на x в тялото на вътрешния let "засенчва" (? shadows)  
    ;; тази от външния let-израз
    (let 
        ((x 2) 
         (y 3))
    (let                    ;; втори let, вложен в тялото на първия
        ((x 7)
         (z (+ x y)))       ;; тук x е 2, защото вътрешния x още не се е  
                            ;; свръзал със стойността си
    (* z x)))               ;; тук x е 7, защото сме в тялото на втория let
    ```

### let*  
- синтаксис - същия като на let-изразите
    
    ```scheme
    (let* 
        ((variable1 value1)
         (variable2 value2)
         ;; ...
         (variablen valuen))
    body)
    ```

- разлики с let - value изразите се изчисляват и свързват с променливите си variable последователно от ляво надясно; съответно scope-a на всяка от променливите е от дефиницията и до края на let израза

    ```scheme
    ;; грешка - cannot reference an identifier before  
    ;; its definition - променливата а все още не е  
    ;; свързана със стойността
    (let
        ((a      2)
         (b (+ a 1)))
    (+ a b))

    ;; връща 5
    (let*
        ((a      2)
         (b (+ a 1)))
    (+ a b))    
    ```

- използваме let* вместо let, когато съществува някаква линейна зависимост между стойностите на променливите

## Функции от по-висок ред

- функциите в Scheme са "first-class citizens" - т.е. те са стойности, които могат да бъдат подавани наоколо, подобно на всички останали стойности (числа, списъци)
 
- функция от по-висок ред - приема функция като аргумент и/или връща функция като резултат

    ```scheme
    (define (apply2 func a b)
        (func a b))

    (apply2 + 1 2)
    (apply2 - 1 2)
    (apply2 expt 2 3)
    (apply2 string-append "obicham" " sirene")
    ```

    ![xzibit-fp](https://lifebeyondfife.com/wp-content/uploads/2015/05/functions.jpg)

- допринасят за модулярността на програмата - използването на по-общи функции от висок ред, които са приложими в различни случаи, прави програмата по-четима от писането на сходни функции за всеки отделен случай

    ```scheme
    ;; помощна функция, игнорираме я
    (define (cube x) 
        (* x x x))

    ;; функция, която намира сумата на числата в даден интервал [a, b]
    (define (sum-interval a b)
        (if (> a b)
            0
            (+ a (sum-interval (+ a 1) b))))

    ;; функция, която намира сумата от кубовете на всяко втори число в  
    ;; даден интервал [a, b]
    (define (sum-interval-cubes a b)
        (if (> a b)
            0
            (+ (cube a) (sum-interval-cubes (+ a 2) b))))
    ```

    Очевидно, двете функции са почти еднакви. Нещата, по които се различават, са:
    1. функцията, която прилагаме върху елементите на редицата докато ги събираме (в първия случай функцията е идентитет, във втория - повдигане на трета степен)
    2. функцията, определяща стъпката/разликата между два последователни елемента на редицата (в първия случай увеличаваме a с 1, във втория - с 2)

    Ако изнесем 3-те разлики в променливи (входни параметри на някоя нова функция) можем да обобщим s `sum-interval` и `sum-iterval-cube` така:

    ```scheme
    ;; обобщената функция sum приема като аргументи
    ;; a и b - начало и край на интервала, който обхождаме
    ;; term  - функция, която прилагаме към всеки член на редицата
    ;; next  - функция, която определя следващия член от редицата  
    ;; спрямо предходния
    (define (sum a b term next)
        (if (> a b)
            0
            (+ 
                (term a)
                (sum (next a) b term next))))

    ;; можем да изразим sum-interval чрез sum
    (define (identity a)       a)
    (define (succ     a) (+ a 1))

    (define (sum-interval a b)
        (sum a b identity succ))

    ;; можем да изразим и sum-interval-cubes чрез sum
    (define (cube     a) (* a a a))
    (define (skip-one a)   (+ a 2))

    (define (sum-interval-cubes a b)
        (sum a b cube skip-one))
    ```

## sum, product, accumulate

Подобно на обобщената функция sum, можем да напишем и обобщена product функция:

```scheme
;; нищо ново тук, копираме фунцкията от по-горе
(define (sum a b term next)
    (if (> a b)
        0
        (+ 
            (term a)
            (sum (next a) b term next))))

(define (product a b term next)    
    (if (> a b)        
        1        
        (*
            (term a)
            (product (next a) b term next))))
            
;; връща произведението на числата в интервала [a, b]
(define (product-interval a b)    
    (product a b identity succ))
```
Пак стигнахме до почти еднакви функции - значи можем да ги обобщим още.

Нещата, по които се различават sum и product, са:
- операцията, която прилагаме между елементите на редицата, за да получим крайния резултат (+ или *)
- стойността, която използваме за дъно - неутралния елемент на операцията (при sum неутралният елемент е 0, докато при product - 1)

Изнасяме двете разлики като аргументи на нова, още по-абстрактна функция:

```scheme
(define (accumulate operation base start end term next)
  (if (> start end)
      base
      (operation 
            (term start) 
            (accumulate operation base (next start) end term next))))

(define (sum-interval a b)
    (accumulate + 0 a b identity succ))

(define (product-interval a b)
    (accumulate * 1 a b identity succ))
```


## Lambda функции

- анонимни функции - нямат име
- TODO

## Задачи

1. Дефинирайте функция `(apply-twice f arg)`, която прилага функцията f два пъти  
пример: 
    
    ```scheme
    (apply-twice sqrt 16) ;; връща 2
    ```

2. Дефинирайте функция `(apply-n n f arg)`, която прилага функцията f n пъти
пример: 
    
    ```scheme
    (apply-n 3 sqrt 256) ;; връща 2
    ```

3. Дефинирайте функция `(factorial n)`, използвайки дефинираната по-горе `accumulate`

4. Дефинирайте функция `(power base exp`, използвайки дефинираната по-горе `accumulate`

5. Дефинирайте функция `filter-accumulate` по подобие на `accumulate`. `filter-accumulate` приема допълнителен аргумент - предикат, който определя дали елементът трябва да участва в крайния резултат, или не
